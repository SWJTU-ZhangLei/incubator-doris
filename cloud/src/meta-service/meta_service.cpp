
// clang-format off
#include "meta_service.h"
#include "meta-service/doris_txn.h"
#include "meta-service/keys.h"
#include "common/config.h"
#include "common/util.h"

#include "brpc/closure_guard.h"
#include "brpc/controller.h"
#include "google/protobuf/util/json_util.h"

#include <chrono>
#include <limits>
#include <memory>
#include <string>
#include <sstream>
// clang-format on

using namespace std::chrono;

namespace selectdb {

static constexpr uint32_t VERSION_STAMP_LEN = 10;

MetaServiceImpl::MetaServiceImpl(std::shared_ptr<TxnKv> txn_kv) {
    txn_kv_ = txn_kv;
}

MetaServiceImpl::~MetaServiceImpl() {}

//TODO: we need move begin/commit etc txn to TxnManager
void MetaServiceImpl::begin_txn(::google::protobuf::RpcController* controller,
                                const ::selectdb::BeginTxnRequest* request,
                                ::selectdb::BeginTxnResponse* response,
                                ::google::protobuf::Closure* done) {
    auto ctrl = static_cast<brpc::Controller*>(controller);
    LOG(INFO) << __PRETTY_FUNCTION__ << " rpc from " << ctrl->remote_side()
              << " request=" << request->DebugString();
    brpc::ClosureGuard closure_guard(done);
    int ret = 0;
    MetaServiceCode code = MetaServiceCode::OK;
    std::string msg = "OK";
    [[maybe_unused]] std::stringstream ss;
    std::unique_ptr<int, std::function<void(int*)>> defer_status(
            (int*)0x01, [&code, &msg, &response, &ctrl](int*) {
                response->mutable_status()->set_code(code);
                response->mutable_status()->set_msg(msg);
                LOG(INFO) << "finish " << __PRETTY_FUNCTION__ << " " << ctrl->remote_side() << " "
                          << msg << " response" << response->DebugString();
            });
    if (!request->has_txn_info()) {
        code = MetaServiceCode::INVALID_ARGUMENT_ERR;
        msg = "invalid argument, missing txn info";
        return;
    }

    auto& txn_info = const_cast<TxnInfoPB&>(request->txn_info());
    std::string label = txn_info.has_label() ? txn_info.label() : "";
    int64_t db_id = txn_info.has_db_id() ? txn_info.db_id() : -1;

    if (label.empty() || db_id < 0) {
        code = MetaServiceCode::INVALID_ARGUMENT_ERR;
        ss << "invalid argument, label=" << label << " db_id=" << db_id;
        msg = ss.str();
        return;
    }

    //1. Generate version stamp for txn id
    std::unique_ptr<Transaction> txn;
    ret = txn_kv_->create_txn(&txn);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_CREATE_ERR;
        ss << "txn_kv_->create_txn() failed, ret=" << ret << " label=" << label
           << " db_id=" << db_id;
        msg = ss.str();
        return;
    }

    std::string instance_id = "instance_id_deadbeef";
    std::string txn_idx_key;
    std::string txn_idx_val;

    TxnIndexKeyInfo txn_idx_key_info {instance_id, db_id, label};
    txn_index_key(txn_idx_key_info, &txn_idx_key);

    ret = txn->get(txn_idx_key, &txn_idx_val);
    if (ret < 0) {
        code = MetaServiceCode::KV_TXN_GET_ERR;
        ss << "txn->get failed(), ret=" << ret;
        msg = ss.str();
        return;
    }
    LOG(INFO) << "txn->get txn_idx_key=" << hex(txn_idx_key) << " txn_idx_val=" << txn_idx_val
              << " ret=" << ret;

    //ret == 0 means label has previous txn ids.
    if (ret == 0) {
        txn_idx_val = txn_idx_val.substr(0, txn_idx_val.size() - VERSION_STAMP_LEN);
    }

    //ret > 0, means label not exist previously.
    txn->atomic_set_ver_value(txn_idx_key, txn_idx_val);
    LOG(INFO) << "txn->atomic_set_ver_value txn_idx_key=" << hex(txn_idx_key)
              << " txn_idx_val=" << txn_idx_val;
    ret = txn->commit();
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_COMMIT_ERR;
        std::stringstream ss;
        ss << "txn->commit failed(), ret=" << ret;
        msg = ss.str();
        return;
    }

    //2. Get txn id from version stamp
    txn.reset();
    txn_kv_->create_txn(&txn);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_CREATE_ERR;
        msg = "failed to create txn when get txn id.";
        return;
    }

    txn_idx_val.clear();
    ret = txn->get(txn_idx_key, &txn_idx_val);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_GET_ERR;
        ss << "txn->get() failed, ret=" << ret;
        msg = ss.str();
        return;
    }

    std::string txn_id_str =
            txn_idx_val.substr(txn_idx_val.size() - VERSION_STAMP_LEN, txn_idx_val.size());
    // Generated by TxnKv system
    int64_t txn_id = 0;
    ret = get_txn_id_from_fdb_ts(txn_id_str, &txn_id);
    if (ret != 0) {
        code = MetaServiceCode::TXN_GEN_ID_ERR;
        ss << "get_txn_id_from_fdb_ts() failed, ret=" << ret;
        msg = ss.str();
        return;
    }

    LOG(INFO) << "get_txn_id_from_fdb_ts() txn_id=" << txn_id;

    std::unique_ptr<int, std::function<void(int*)>> defer_(
            (int*)0x01, [&code, &msg, &response, &ctrl](int*) {
                response->mutable_status()->set_code(code);
                response->mutable_status()->set_msg(msg);
                LOG(INFO) << "finish " << __PRETTY_FUNCTION__ << " " << ctrl->remote_side() << " "
                          << msg << " response" << response->DebugString();
            });

    TxnLabelToIdsPB label_to_ids;
    if (txn_idx_val.size() > VERSION_STAMP_LEN) {
        //3. Check label
        //txn_idx_val.size() > VERSION_STAMP_LEN means label has previous txn ids.
        ;
        std::string label_to_ids_str = txn_idx_val.substr(0, txn_idx_val.size() - 10);
        if (!label_to_ids.ParseFromString(label_to_ids_str)) {
            code = MetaServiceCode::PROTOBUF_PARSE_ERR;
            msg = "label_to_ids->ParseFromString() failed.";
            return;
        }

        // Check if label already used, by following steps
        // 1. get all existing transactions
        // 2. if there is a PREPARE transaction, check if this is a retry request.
        // 3. if there is a non-aborted transaction, throw label already used exception.

        for (auto& cur_txn_id : label_to_ids.txn_ids()) {
            std::string cur_txn_inf_key;
            std::string cur_txn_inf_val;
            TxnInfoKeyInfo cur_txn_inf_key_info {instance_id, db_id, cur_txn_id};
            txn_info_key(cur_txn_inf_key_info, &cur_txn_inf_key);
            ret = txn->get(cur_txn_inf_key, &cur_txn_inf_val);
            if (ret < 0) {
                code = MetaServiceCode::KV_TXN_GET_ERR;
                ss << "txn->get() failed, cur_txn_id=" << cur_txn_id << " ret={}" << ret;
                msg = ss.str();
                return;
            }

            if (ret == 1) {
                //label_to_idx and txn info inconsistency.
                code = MetaServiceCode::TXN_ID_NOT_FOUND;
                ss << "txn->get() failed, cur_txn_id=" << cur_txn_id << " label=" << label
                   << " ret=" << ret;
                msg = ss.str();
                return;
            }
            TxnInfoPB cur_txn_info;
            if (!cur_txn_info.ParseFromString(cur_txn_inf_val)) {
                code = MetaServiceCode::PROTOBUF_PARSE_ERR;
                ss << "cur_txn_info->ParseFromString() failed, cur_txn_id=" << cur_txn_id
                   << " label=" << label << " ret={}" << ret;
                msg = ss.str();
                return;
            }

            if (cur_txn_info.status() == TxnStatusPB::TXN_STATUS_ABORTED) {
                continue;
            }

            if (cur_txn_info.status() == TxnStatusPB::TXN_STATUS_PREPARED ||
                cur_txn_info.status() == TxnStatusPB::TXN_STATUS_PRECOMMITTED) {
                // clang-format off
                if (cur_txn_info.has_request_unique_id() && txn_info.has_request_unique_id() &&
                    ((cur_txn_info.request_unique_id().hi() == txn_info.request_unique_id().hi()) && 
                     (cur_txn_info.request_unique_id().lo() == txn_info.request_unique_id().lo()))) {

                    code = MetaServiceCode::TXN_DUPLICATED_REQ;
                    ss << "db_id=" << db_id << " label=" << label << " dup begin txn request.";
                    msg = ss.str();
                    return;
                }
                // clang-format on
            }
            code = MetaServiceCode::TXN_LABEL_ALREADY_USED;
            ss << "db_id=" << db_id << " label=" << label << " already used.";
            msg = ss.str();
            return;
        }
    }

    // Update txn_info to be put into TxnKv
    // Update txn_id in PB
    txn_info.set_txn_id(txn_id);
    // TODO:
    // check initial status must be TXN_STATUS_PREPARED or TXN_STATUS_UNKNOWN
    txn_info.set_status(TxnStatusPB::TXN_STATUS_PREPARED);

    auto now_time = system_clock::now();
    uint64_t prepare_time = duration_cast<milliseconds>(now_time.time_since_epoch()).count();

    txn_info.set_prepare_time(prepare_time);

    //4. put txn info and db_tbl
    std::string txn_inf_key;
    std::string txn_inf_val;
    TxnInfoKeyInfo txn_inf_key_info {instance_id, db_id, txn_id};
    txn_info_key(txn_inf_key_info, &txn_inf_key);
    if (!txn_info.SerializeToString(&txn_inf_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        msg = "failed to serialize txn_info";
        return;
    }

    std::string txn_db_key;
    std::string txn_db_val;
    TxnDbTblKeyInfo txn_db_key_info {instance_id, txn_id};
    txn_db_tbl_key(txn_db_key_info, &txn_db_key);
    txn_db_val = std::string((char*)&db_id, sizeof(db_id));

    std::string txn_run_key;
    std::string txn_run_val;
    TxnRunningKeyInfo txn_run_key_info {instance_id, db_id, txn_id};
    txn_running_key(txn_run_key_info, &txn_run_key);
    TxnRunningInfoPB running_val_pb;
    running_val_pb.set_db_id(db_id);
    for (auto i : txn_info.table_ids()) running_val_pb.add_table_ids(i);

    label_to_ids.add_txn_ids(txn_id);
    if (!label_to_ids.SerializeToString(&txn_idx_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        msg = "failed to serialize label_to_ids";
        return;
    }
    txn->atomic_set_ver_value(txn_idx_key, txn_idx_val);
    LOG(INFO) << "txn->atomic_set_ver_value txn_idx_key=" << hex(txn_idx_key)
              << " txn_idx_val=" << txn_idx_val;

    txn->put(txn_inf_key, txn_inf_val);
    txn->put(txn_db_key, txn_db_val);
    txn->put(txn_run_key, txn_run_val);
    LOG(INFO) << "xxx put txn_inf_key=" << hex(txn_inf_key);
    LOG(INFO) << "xxx put txn_run_key=" << hex(txn_run_key);
    LOG(INFO) << "xxx put txn_db_key=" << hex(txn_db_key);
    ret = txn->commit();
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_COMMIT_ERR;
        msg = "failed to commit txn kv";
        return;
    }

    response->set_txn_id(txn_id);
}
void MetaServiceImpl::precommit_txn(::google::protobuf::RpcController* controller,
                                    const ::selectdb::PrecommitTxnRequest* request,
                                    ::selectdb::PrecommitTxnResponse* response,
                                    ::google::protobuf::Closure* done) {}

/**
 * 0. Extract txn_id from request
 * 1. Get db id from TxnKv with txn_id
 * 2. Get TxnInfo from TxnKv with db_id and txn_id
 * 3. Get tmp rowset meta, there may be several or hundred of tmp rowsets
 * 4. Get versions of each rowset
 * 5. Put rowset meta, which will be visible to user
 * 6. Put TxnInfo back into TxnKv with updated txn status (committed)
 * 7. Update versions of each partition
 * 8. Remove tmp rowset meta
 *
 * Note: getting version and all changes maded are in a single TxnKv transaction:
 *       step 5, 6, 7, 8
 */
void MetaServiceImpl::commit_txn(::google::protobuf::RpcController* controller,
                                 const ::selectdb::CommitTxnRequest* request,
                                 ::selectdb::CommitTxnResponse* response,
                                 ::google::protobuf::Closure* done) {
    auto ctrl = static_cast<brpc::Controller*>(controller);
    LOG(INFO) << "rpc from " << ctrl->remote_side() << " request=" << request->DebugString();
    brpc::ClosureGuard closure_guard(done);
    int ret = 0;
    MetaServiceCode code = MetaServiceCode::OK;
    std::string msg = "OK";
    std::string instance_id = "instance_id_deadbeef";
    [[maybe_unused]] std::stringstream ss;
    std::unique_ptr<int, std::function<void(int*)>> defer_status(
            (int*)0x01, [&code, &msg, &response, &ctrl](int*) {
                response->mutable_status()->set_code(code);
                response->mutable_status()->set_msg(msg);
                LOG(INFO) << "finish " << __PRETTY_FUNCTION__ << " " << ctrl->remote_side() << " "
                          << msg;
            });

    std::unique_ptr<Transaction> txn;
    ret = txn_kv_->create_txn(&txn);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_CREATE_ERR;
        msg = "filed to create txn";
        return;
    }

    int64_t txn_id = request->has_txn_id() ? request->txn_id() : -1;
    if (txn_id < 0) {
        code = MetaServiceCode::INVALID_ARGUMENT_ERR;
        msg = "no txn id";
        return;
    }

    //Get db id with txn id
    std::string txn_db_key;
    std::string txn_db_val;
    TxnDbTblKeyInfo txn_db_key_info {instance_id, txn_id};
    txn_db_tbl_key(txn_db_key_info, &txn_db_key);
    ret = txn->get(txn_db_key, &txn_db_val);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_GET_ERR;
        ss << "failed to get db id with txn_id=" << txn_id << " ret={}" << ret;
        msg = ss.str();
        return;
    }

    int64_t db_id = *reinterpret_cast<const int64_t*>(txn_db_val.data());

    // Get txn info with db_id and txn_id
    std::string txn_inf_key; // Will be used when saving updated txn
    std::string txn_inf_val; // Will be reused when saving updated txn
    TxnInfoKeyInfo txn_inf_key_info {instance_id, db_id, txn_id};
    txn_info_key(txn_inf_key_info, &txn_inf_key);
    ret = txn->get(txn_inf_key, &txn_inf_val);
    if (ret != 0) {
        code = ret > 0 ? MetaServiceCode::TXN_ID_NOT_FOUND : MetaServiceCode::KV_TXN_GET_ERR;
        ss << "failed to get db id with db_id=" << db_id << " txn_id=" << txn_id << " ret=" << ret;
        msg = ss.str();
        return;
    }

    TxnInfoPB txn_info;
    if (!txn_info.ParseFromString(txn_inf_val)) {
        code = MetaServiceCode::PROTOBUF_PARSE_ERR;
        ss << "failed to parse txn_inf db_id=" << db_id << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    // TODO: do more check like txn state, 2PC etc.
    DCHECK(txn_info.txn_id() == txn_id);
    if (txn_info.status() == TxnStatusPB::TXN_STATUS_ABORTED) {
        code = MetaServiceCode::TXN_ALREADY_ABORTED;
        ss << "transaction is already aborted: txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    if (txn_info.status() == TxnStatusPB::TXN_STATUS_VISIBLE) {
        code = MetaServiceCode::OK;
        ss << "ransaction is already visible: txn_id=" << txn_id;
        msg = ss.str();
    }

    if (request->has_is_2pc() && TxnStatusPB::TXN_STATUS_PREPARED) {
        code = MetaServiceCode::TXN_INVALID_STATUS;
        ss << "transaction is prepare, not pre-committed: txn_id=" << txn_id;
        msg = ss.str();
        return;
    }
    LOG(INFO) << "xxx txn_info=" << txn_info.DebugString();

    // Get temporary rowsets involved in the txn
    // This is a range scan
    MetaRowsetTmpKeyInfo rs_tmp_key_info0 {instance_id, txn_id, ""};
    MetaRowsetTmpKeyInfo rs_tmp_key_info1 {instance_id, txn_id + 1, ""};
    std::string rs_tmp_key0;
    std::string rs_tmp_key1;
    meta_rowset_tmp_key(rs_tmp_key_info0, &rs_tmp_key0);
    meta_rowset_tmp_key(rs_tmp_key_info1, &rs_tmp_key1);
    std::unique_ptr<RangeGetIterator> it;
    ret = txn->get(rs_tmp_key0, rs_tmp_key1, &it);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_GET_ERR;
        ss << "no rowset found for txn=" << txn_id;
        msg = ss.str();
        return;
    }
    // TODO: check more rowset_meta, it->more()?
    // Get rowset meta that should be commited
    std::vector<doris::RowsetMetaPB> rowset_meta;
    while (it->has_next()) {
        auto [k, v] = it->next();
        LOG(INFO) << "xxx range_get rowset_tmp_key=" << hex(k);
        rowset_meta.emplace_back();
        if (!rowset_meta.back().ParseFromArray(v.data(), v.size())) {
            code = MetaServiceCode::PROTOBUF_PARSE_ERR;
            ss << "malformed rowset meta, unable to initialize, txn_id=" << txn_id;
            msg = ss.str();
            return;
        }
    }

    // Prepare rowset meta and new_versions
    std::vector<std::pair<std::string, std::string>> rowsets;
    std::map<std::string, std::string> new_versions;
    std::map<int64_t, int64_t> table_ids; // tablet_id -> table_id
    rowsets.reserve(rowset_meta.size());
    for (auto& i : rowset_meta) {
        // Get version for the rowset

        if (table_ids.count(i.tablet_id()) == 0) {
            MetaTabletTblKeyInfo key_info {instance_id, i.tablet_id()};
            std::string key;
            std::string val;
            meta_tablet_table_key(key_info, &key);
            txn->get(key, &val); // TODO: check result, it must be 0
            table_ids.emplace(i.tablet_id(), *reinterpret_cast<int64_t*>(val.data()));
        }

        int64_t tbl_id = table_ids[i.tablet_id()];
        int64_t partition_id = i.partition_id();

        VersionKeyInfo ver_key_info {instance_id, db_id, tbl_id, partition_id};
        std::string ver_key;
        version_key(ver_key_info, &ver_key);
        int64_t version = -1;
        std::string ver_str;
        // TODO: read version from cache (the map)
        ret = txn->get(ver_key, &ver_str);
        if (ret != 1 && ret != 0) {
            code = MetaServiceCode::KV_TXN_GET_ERR;
            ss << "failed to get version, table_id=" << tbl_id << "partition_id=" << partition_id
               << " key=" << hex(ver_key);
            msg = ss.str();
            LOG(INFO) << msg;
            return;
        }
        // Maybe first version
        version = ret == 1 ? 1 : *reinterpret_cast<const int64_t*>(ver_str.data());
        int64_t new_version = version + 1;
        std::string new_version_str((char*)&new_version, sizeof(new_version));
        new_versions.insert({std::move(ver_key), std::move(new_version_str)});

        // Update rowset version
        i.set_start_version(new_version);
        i.set_end_version(new_version);

        std::string key;
        std::string val;
        MetaRowsetKeyInfo key_info {instance_id, i.tablet_id(), i.end_version()};
        meta_rowset_key(key_info, &key);
        if (!i.SerializeToString(&val)) {
            code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
            msg = "failed to serialize rowset_meta";
            return;
        }
        rowsets.emplace_back(std::move(key), std::move(val));
    }

    // Save rowset meta
    for (auto& i : rowsets) {
        txn->put(i.first, i.second);
        LOG(INFO) << "xxx put rowset_key=" << hex(i.first);
    }

    // Save versions
    for (auto& i : new_versions) {
        txn->put(i.first, i.second);
        LOG(INFO) << "xxx put version_key=" << hex(i.first);
    }

    // Update txn_info
    txn_info.set_status(TxnStatusPB::TXN_STATUS_VISIBLE);

    auto now_time = system_clock::now();
    uint64_t commit_time = duration_cast<milliseconds>(now_time.time_since_epoch()).count();
    txn_info.set_commit_time(commit_time);
    txn_info.set_finish_time(commit_time);
    txn_inf_val.clear();
    if (!txn_info.SerializeToString(&txn_inf_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        msg = "failed to serialize txn_info when saving";
        return;
    }
    txn->put(txn_inf_key, txn_inf_val);
    LOG(INFO) << "xxx put txn_inf_key=" << hex(txn_inf_key);

    // Remove tmp rowset meta
    it->reset(); // Reuse what just scanned
    while (it->has_next()) {
        auto [k, _] = it->next();
        txn->remove(k);
        LOG(INFO) << "xxx remove tmp_rowset_key=" << hex(k);
    }

    ret = txn->commit();
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_COMMIT_ERR;
        msg = "failed to save tablet meta";
        return;
    }
}

void MetaServiceImpl::abort_txn(::google::protobuf::RpcController* controller,
                                const ::selectdb::AbortTxnRequest* request,
                                ::selectdb::AbortTxnResponse* response,
                                ::google::protobuf::Closure* done) {
    auto ctrl = static_cast<brpc::Controller*>(controller);
    LOG(INFO) << "abort_txn rpc from " << ctrl->remote_side()
              << " request=" << request->DebugString();
    brpc::ClosureGuard closure_guard(done);
    int ret = 0;
    MetaServiceCode code = MetaServiceCode::OK;
    std::string msg = "OK";
    std::string instance_id = "instance_id_deadbeef";
    [[maybe_unused]] std::stringstream ss;
    std::unique_ptr<int, std::function<void(int*)>> defer_status(
            (int*)0x01, [&code, &msg, &response, &ctrl](int*) {
                response->mutable_status()->set_code(code);
                response->mutable_status()->set_msg(msg);
                LOG(INFO) << "finish " << __PRETTY_FUNCTION__ << " " << ctrl->remote_side() << " "
                          << msg;
            });

    // Get txn id
    int64_t txn_id = request->has_txn_id() ? request->txn_id() : -1;
    std::string label = request->has_label() ? request->label() : "";
    int64_t db_id = request->has_db_id() ? request->db_id() : -1;
    if (txn_id < 0 && (label.size() == 0 || db_id < 0)) {
        code = MetaServiceCode::INVALID_ARGUMENT_ERR;
        msg = "invalid txn id and lable.";
        return;
    }

    std::unique_ptr<Transaction> txn;
    ret = txn_kv_->create_txn(&txn);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_CREATE_ERR;
        LOG(WARNING) << "failed to create meta serivce txn ret= " << ret;
        ss << "filed to txn_kv_->create_txn(), txn_id=" << txn_id << " label=" << label;
        msg = ss.str();
        return;
    }

    std::string txn_inf_key; // Will be used when saving updated txn
    std::string txn_inf_val; // Will be reused when saving updated txn
    TxnInfoPB txn_info;

    //TODO: split with two function.
    //there two ways to abort txn:
    //1. abort txn by txn id
    //2. abort txn by label and db_id
    if (db_id < 0) {
        //abort txn by txn id
        // Get db id with txn id

        std::string txn_db_key;
        std::string txn_db_val;

        //not provide db_id, we need read from disk.
        if (!request->has_db_id()) {
            TxnDbTblKeyInfo txn_db_key_info {instance_id, txn_id};
            txn_db_tbl_key(txn_db_key_info, &txn_db_key);
            ret = txn->get(txn_db_key, &txn_db_val);
            if (ret != 0) {
                code = ret > 0 ? MetaServiceCode::TXN_ID_NOT_FOUND
                               : MetaServiceCode::KV_TXN_GET_ERR;
                ss << "failed to get db id with txn_id=" << txn_id << " ret=" << ret;
                msg = ss.str();
                return;
            }
            db_id = *reinterpret_cast<const int64_t*>(txn_db_val.data());
        } else {
            db_id = request->db_id();
        }

        // Get txn info with db_id and txn_id
        TxnInfoKeyInfo txn_inf_key_info {instance_id, db_id, txn_id};
        txn_info_key(txn_inf_key_info, &txn_inf_key);
        ret = txn->get(txn_inf_key, &txn_inf_val);
        if (ret != 0) {
            code = ret > 0 ? MetaServiceCode::TXN_ID_NOT_FOUND : MetaServiceCode::KV_TXN_GET_ERR;
            ss << "failed to get db id with db_id=" << db_id << "txn_id=" << txn_id
               << "ret=" << ret;
            msg = ss.str();
            return;
        }

        if (!txn_info.ParseFromString(txn_inf_val)) {
            code = MetaServiceCode::PROTOBUF_PARSE_ERR;
            ss << "failed to parse txn_info db_id=" << db_id << "txn_id=" << txn_id;
            msg = ss.str();
            return;
        }

        DCHECK(txn_info.txn_id() == txn_id);

        //check state is valid.
        if (txn_info.status() == TxnStatusPB::TXN_STATUS_ABORTED) {
            code = MetaServiceCode::TXN_ALREADY_ABORTED;
            ss << "transaction is already abort db_id=" << db_id << "txn_id=" << txn_id;
            msg = ss.str();
            return;
        }
        if (txn_info.status() == TxnStatusPB::TXN_STATUS_VISIBLE) {
            code = MetaServiceCode::TXN_ALTEADY_VISIBLE;
            ss << "transaction is already visible db_id=" << db_id << "txn_id=" << txn_id;
            msg = ss.str();
            return;
        }
    } else {
        //abort txn by label.
        std::string txn_idx_key;
        std::string txn_idx_val;

        TxnIndexKeyInfo txn_idx_key_info {instance_id, db_id, label};
        txn_index_key(txn_idx_key_info, &txn_idx_key);
        ret = txn->get(txn_idx_key, &txn_idx_val);
        if (ret < 0) {
            code = MetaServiceCode::KV_TXN_GET_ERR;
            ss << "txn->get() failed, ret=" << ret;
            msg = ss.str();
            return;
        }
        //label index not exist
        if (ret > 0) {
            code = MetaServiceCode::TXN_LABEL_NOT_FOUND;
            ss << "label not found db_id=" << db_id << " label=" << label << " ret=" << ret;
            msg = ss.str();
            return;
        }

        TxnLabelToIdsPB label_to_ids;
        DCHECK(txn_idx_val.size() > 10);
        std::string label_to_ids_str = txn_idx_val.substr(0, txn_idx_val.size() - 10);
        if (!label_to_ids.ParseFromString(label_to_ids_str)) {
            code = MetaServiceCode::PROTOBUF_PARSE_ERR;
            msg = "label_to_ids->ParseFromString() failed.";
            return;
        }

        int64_t prepare_txn_id = 0;
        //found prepare state txn for abort
        for (auto& cur_txn_id : label_to_ids.txn_ids()) {
            std::string cur_txn_inf_key;
            std::string cur_txn_inf_val;
            TxnInfoKeyInfo cur_txn_inf_key_info {instance_id, db_id, cur_txn_id};
            txn_info_key(cur_txn_inf_key_info, &cur_txn_inf_key);
            ret = txn->get(cur_txn_inf_key, &cur_txn_inf_val);
            if (ret != 0) {
                code = MetaServiceCode::KV_TXN_GET_ERR;
                std::stringstream ss;
                ss << "txn->get() failed, cur_txn_id=" << cur_txn_id << " ret=" << ret;
                msg = ss.str();
                return;
            }

            if (ret == 0) {
                TxnInfoPB cur_txn_info;
                if (!cur_txn_info.ParseFromString(cur_txn_inf_val)) {
                    code = MetaServiceCode::PROTOBUF_PARSE_ERR;
                    std::stringstream ss;
                    ss << "cur_txn_info->ParseFromString() failed, cur_txn_id=" << cur_txn_id;
                    msg = ss.str();
                    return;
                }
                //TODO: 2pc alse need to check TxnStatusPB::TXN_STATUS_PRECOMMITTED
                if (cur_txn_info.status() == TxnStatusPB::TXN_STATUS_PREPARED) {
                    prepare_txn_id = cur_txn_id;
                    txn_info = std::move(cur_txn_info);
                    txn_inf_key = std::move(cur_txn_inf_key);
                    break;
                }
            }
        }

        if (prepare_txn_id == 0) {
            code = MetaServiceCode::TXN_INVALID_STATUS;
            std::stringstream ss;
            ss << "running transaction not found, db_id=" << db_id << " label=" << label;
            msg = ss.str();
            return;
        }
    }

    auto now_time = system_clock::now();
    uint64_t finish_time = duration_cast<milliseconds>(now_time.time_since_epoch()).count();

    // Update txn_info
    txn_info.set_status(TxnStatusPB::TXN_STATUS_ABORTED);
    txn_info.set_finish_time(finish_time);
    if (request->has_reason()) {
        txn_info.set_reason(request->reason());
    }
    //TODO: update txn attachment
    LOG(INFO) << "txn_info=" << txn_info.DebugString();
    txn_inf_val.clear();
    if (!txn_info.SerializeToString(&txn_inf_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        msg = "failed to serialize txn_info when saving";
        return;
    }
    txn->put(txn_inf_key, txn_inf_val);
    LOG(INFO) << "xxx put txn_inf_key=" << hex(txn_inf_key);
    return;

    ret = txn->commit();
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_COMMIT_ERR;
        msg = "failed to abort meta service txn";
        return;
    }
}

void MetaServiceImpl::get_version(::google::protobuf::RpcController* controller,
                                  const ::selectdb::GetVersionRequest* request,
                                  ::selectdb::GetVersionResponse* response,
                                  ::google::protobuf::Closure* done) {
    auto ctrl = static_cast<brpc::Controller*>(controller);
    LOG(INFO) << "rpc from " << ctrl->remote_side() << " request=" << request->DebugString();
    brpc::ClosureGuard closure_guard(done);
    std::unique_ptr<Transaction> txn;
    int ret = 0;
    MetaServiceCode code = MetaServiceCode::OK;
    std::string msg = "OK";
    std::unique_ptr<int, std::function<void(int*)>> defer_status(
            (int*)0x01, [&code, &msg, &response, &ctrl](int*) {
                response->mutable_status()->set_code(code);
                response->mutable_status()->set_msg(msg);
                LOG(INFO) << "rpc from " << ctrl->remote_side()
                          << " response=" << response->DebugString();
            });

    // TODO(dx): For auth
    std::string cloud_unique_id;
    if (request->has_cloud_unique_id()) {
        cloud_unique_id = request->cloud_unique_id();
    }

    int64_t db_id = request->has_db_id() ? request->db_id() : -1;
    int64_t table_id = request->has_table_id() ? request->table_id() : -1;
    int64_t partition_id = request->has_partition_id() ? request->partition_id() : -1;
    if (db_id == -1 || table_id == -1 || partition_id == -1) {
        msg = "params error, db_id=" + std::to_string(db_id) +
              " table_id=" + std::to_string(table_id) +
              " partition_id=" + std::to_string(partition_id);
        code = MetaServiceCode::INVALID_ARGUMENT_ERR;
        LOG(WARNING) << msg;
        return;
    }

    // TODO(dx): fix it, use instance_id later.
    VersionKeyInfo ver_key_info {"instance_id_deadbeef", db_id, table_id, partition_id};
    std::string ver_key;
    version_key(ver_key_info, &ver_key);

    ret = txn_kv_->create_txn(&txn);
    if (ret != 0) {
        msg = "failed to create txn";
        code = MetaServiceCode::KV_TXN_CREATE_ERR;
        return;
    }

    std::string val;
    // 0 for success get a key, 1 for key not found, negative for error
    ret = txn->get(ver_key, &val);
    LOG(INFO) << "xxx get version_key=" << hex(ver_key);
    if (ret == 0) {
        int64_t version = *reinterpret_cast<int64_t*>(val.data());
        response->set_version(version);
        return;
    } else if (ret == 1) {
        msg = "not found";
        // TODO(dx): find error code enum in proto, or add
        code = MetaServiceCode::VERSION_NOT_FOUND;
        return;
    }
    msg = "failed to get txn";
    code = MetaServiceCode::KV_TXN_GET_ERR;
}

void MetaServiceImpl::create_tablet(::google::protobuf::RpcController* controller,
                                    const ::selectdb::CreateTabletRequest* request,
                                    ::selectdb::MetaServiceGenericResponse* response,
                                    ::google::protobuf::Closure* done) {
    auto ctrl = static_cast<brpc::Controller*>(controller);
    LOG(INFO) << "rpc from " << ctrl->remote_side() << " request=" << request->DebugString();
    brpc::ClosureGuard closure_guard(done);
    int ret = 0;
    MetaServiceCode code = MetaServiceCode::OK;
    std::string msg = "OK";
    std::unique_ptr<int, std::function<void(int*)>> defer_status(
            (int*)0x01, [&ret, &code, &msg, &response, &ctrl](int*) {
                response->mutable_status()->set_code(code);
                response->mutable_status()->set_msg(msg);
                LOG(INFO) << (ret == 0 ? "succ to " : "failed to ") << __PRETTY_FUNCTION__ << " "
                          << ctrl->remote_side() << " " << msg;
            });

    if (!request->has_tablet_meta()) {
        msg = "no tablet meta";
        code = MetaServiceCode::INVALID_ARGUMENT_ERR;
        return;
    }

    auto& tablet_meta = const_cast<doris::TabletMetaPB&>(request->tablet_meta());
    // TODO:
    // process multiple initial rowsets so that we can create table with
    // data -- boostrap
    bool has_first_rowset = tablet_meta.rs_metas_size() > 0;
    doris::RowsetMetaPB first_rowset;
    if (has_first_rowset) {
        first_rowset.CopyFrom(tablet_meta.rs_metas(0));
        tablet_meta.clear_rs_metas(); // Strip off rowset meta
    }

    // TODO: validate tablet meta, check existence
    int64_t table_id = tablet_meta.table_id();
    int64_t tablet_id = tablet_meta.tablet_id();

    std::unique_ptr<Transaction> txn;
    ret = txn_kv_->create_txn(&txn);

    MetaTabletKeyInfo key_info {"instance_id_deadbeef", table_id, tablet_id};
    std::string key;
    std::string val;
    meta_tablet_key(key_info, &key);
    if (!tablet_meta.SerializeToString(&val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        msg = "failed to serialize tablet meta";
        return;
    }
    txn->put(key, val);
    LOG(INFO) << "xxx put tablet_key=" << hex(key);

    // Put first rowset if needed
    std::string rs_key;
    std::string rs_val;
    if (has_first_rowset) {
        MetaRowsetKeyInfo rs_key_info {"instance_id_deadbeef", tablet_id,
                                       first_rowset.end_version()};
        meta_rowset_key(rs_key_info, &rs_key);
        if (!first_rowset.SerializeToString(&rs_val)) {
            code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
            msg = "failed to serialize first rowset meta";
            return;
        }
        txn->put(rs_key, rs_val);
        LOG(INFO) << "xxx rowset key=" << hex(rs_key);
    }

    // Index tablet_id -> table_id
    std::string key1;
    std::string val1(reinterpret_cast<char*>(&table_id), sizeof(table_id));
    MetaTabletTblKeyInfo key_info1 {"instance_id_deadbeef", tablet_id};
    meta_tablet_table_key(key_info1, &key1);
    txn->put(key1, val1);
    LOG(INFO) << "xxx put tablet_table_key=" << hex(key);

    ret = txn->commit();
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_COMMIT_ERR;
        msg = "failed to save tablet meta";
        return;
    }
}

void MetaServiceImpl::drop_tablet(::google::protobuf::RpcController* controller,
                                  const ::selectdb::DropTabletRequest* request,
                                  ::selectdb::MetaServiceGenericResponse* response,
                                  ::google::protobuf::Closure* done) {}

void MetaServiceImpl::get_tablet(::google::protobuf::RpcController* controller,
                                 const ::selectdb::GetTabletRequest* request,
                                 ::selectdb::GetTabletResponse* response,
                                 ::google::protobuf::Closure* done) {
    auto ctrl = static_cast<brpc::Controller*>(controller);
    LOG(INFO) << "rpc from " << ctrl->remote_side() << " request=" << request->DebugString();
    brpc::ClosureGuard closure_guard(done);
    int ret = 0;
    MetaServiceCode code = MetaServiceCode::OK;
    std::string msg = "OK";
    std::unique_ptr<int, std::function<void(int*)>> defer_status(
            (int*)0x01, [&ret, &code, &msg, &response, &ctrl](int*) {
                response->mutable_status()->set_code(code);
                response->mutable_status()->set_msg(msg);
                LOG(INFO) << (ret == 0 ? "succ to " : "failed to ") << __PRETTY_FUNCTION__ << " "
                          << ctrl->remote_side() << " " << msg;
            });

    std::unique_ptr<Transaction> txn;
    ret = txn_kv_->create_txn(&txn);

    // TODO: validate request
    int64_t tablet_id = request->tablet_id();
    MetaTabletTblKeyInfo key_info0 {"instance_id_deadbeef", tablet_id};
    std::string key0;
    std::string val0;
    meta_tablet_table_key(key_info0, &key0);
    ret = txn->get(key0, &val0);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_GET_ERR;
        msg = "failed to get table id from tablet_id";
        return;
    }

    int64_t table_id = *reinterpret_cast<int64_t*>(val0.data());
    MetaTabletKeyInfo key_info1 {"instance_id_deadbeef", table_id, tablet_id};
    std::string key1;
    std::string val1;
    meta_tablet_key(key_info1, &key1);
    ret = txn->get(key1, &val1);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_GET_ERR;
        msg = "failed to get tablet";
        msg += (ret == 1 ? ": not found" : "");
        return;
    }

    if (!response->mutable_tablet_meta()->ParseFromString(val1)) {
        code = MetaServiceCode::PROTOBUF_PARSE_ERR;
        msg = "malformed tablet meta, unable to initialize";
        return;
    }
}

void MetaServiceImpl::create_rowset(::google::protobuf::RpcController* controller,
                                    const ::selectdb::CreateRowsetRequest* request,
                                    ::selectdb::MetaServiceGenericResponse* response,
                                    ::google::protobuf::Closure* done) {
    auto ctrl = static_cast<brpc::Controller*>(controller);
    LOG(INFO) << "rpc from " << ctrl->remote_side() << " request=" << request->DebugString();
    brpc::ClosureGuard closure_guard(done);
    int ret = 0;
    MetaServiceCode code = MetaServiceCode::OK;
    std::string msg = "OK";
    std::unique_ptr<int, std::function<void(int*)>> defer_status(
            (int*)0x01, [&ret, &code, &msg, &response, &ctrl](int*) {
                response->mutable_status()->set_code(code);
                response->mutable_status()->set_msg(msg);
                LOG(INFO) << (ret == 0 ? "succ to " : "failed to ") << __PRETTY_FUNCTION__ << " "
                          << ctrl->remote_side() << " " << msg;
            });

    if (!request->has_rowset_meta()) {
        code = MetaServiceCode::INVALID_ARGUMENT_ERR;
        msg = "no rowset meta";
        return;
    }
    // TODO: validate rowset meta, check existence
    bool temporary = request->has_temporary() && request->temporary() ? true : false;
    int64_t tablet_id = request->rowset_meta().tablet_id();
    int64_t end_version = request->rowset_meta().end_version();
    std::string rowset_id = request->rowset_meta().rowset_id_v2();

    std::string key;
    std::string val;

    if (temporary) {
        int64_t txn_id = request->rowset_meta().txn_id();
        MetaRowsetTmpKeyInfo key_info {"instance_id_deadbeef", txn_id, rowset_id};
        meta_rowset_tmp_key(key_info, &key);
    } else {
        MetaRowsetKeyInfo key_info {"instance_id_deadbeef", tablet_id, end_version};
        meta_rowset_key(key_info, &key);
    }

    if (!request->rowset_meta().SerializeToString(&val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        msg = "failed to serialize rowset meta";
        return;
    }

    std::unique_ptr<Transaction> txn;
    ret = txn_kv_->create_txn(&txn);
    txn->put(key, val);
    LOG(INFO) << "xxx put" << (temporary ? " tmp " : " ") << "create_rowset_key " << hex(key);
    ret = txn->commit();
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_COMMIT_ERR;
        msg = "failed to save rowset meta";
        return;
    }
}

void MetaServiceImpl::get_rowset(::google::protobuf::RpcController* controller,
                                 const ::selectdb::GetRowsetRequest* request,
                                 ::selectdb::GetRowsetResponse* response,
                                 ::google::protobuf::Closure* done) {
    auto ctrl = static_cast<brpc::Controller*>(controller);
    LOG(INFO) << "rpc from " << ctrl->remote_side() << " request: " << request->DebugString();
    brpc::ClosureGuard closure_guard(done);
    int ret = 0;
    MetaServiceCode code = MetaServiceCode::OK;
    std::string msg = "OK";
    std::unique_ptr<int, std::function<void(int*)>> defer_status(
            (int*)0x01, [ret, &code, &msg, &response, &ctrl](int*) {
                response->mutable_status()->set_code(code);
                response->mutable_status()->set_msg(msg);
                LOG(INFO) << (ret == 0 ? "succ to " : "failed to ") << __PRETTY_FUNCTION__ << " "
                          << ctrl->remote_side() << " " << msg;
            });

    int64_t tablet_id = request->tablet_id();
    int64_t start = request->start_version();
    int64_t end = request->end_version();
    end = end < 0 ? std::numeric_limits<int64_t>::max() - 1 : end;

    std::unique_ptr<Transaction> txn;
    ret = txn_kv_->create_txn(&txn);

    // TODO: validate request
    MetaRowsetKeyInfo key_info0 {"instance_id_deadbeef", tablet_id, start};
    MetaRowsetKeyInfo key_info1 {"instance_id_deadbeef", tablet_id, end + 1};
    std::string key0;
    std::string key1;
    meta_rowset_key(key_info0, &key0);
    meta_rowset_key(key_info1, &key1);
    std::unique_ptr<RangeGetIterator> it;
    ret = txn->get(key0, key1, &it);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_GET_ERR;
        msg = "failed to get rowset";
        msg += (ret == 1 ? ": not found" : "");
        return;
    }

    while (it->has_next()) {
        auto [k, v] = it->next();
        LOG(INFO) << "xxx range get rowset_key=" << hex(k);
        std::string val(v.data(), v.size());
        auto rs = response->add_rowset_meta();
        if (!rs->ParseFromString(val)) {
            code = MetaServiceCode::PROTOBUF_PARSE_ERR;
            msg = "malformed tablet meta, unable to initialize";
            return;
        }
    }
}

void MetaServiceImpl::http(::google::protobuf::RpcController* controller,
                           const ::selectdb::MetaServiceHttpRequest* request,
                           ::selectdb::MetaServiceHttpResponse* response,
                           ::google::protobuf::Closure* done) {
    auto cntl = static_cast<brpc::Controller*>(controller);
    LOG(INFO) << "rpc from " << cntl->remote_side() << " request: " << request->DebugString();
    brpc::ClosureGuard closure_guard(done);
    int ret = 0;
    int status_code = 200;
    std::string msg = "OK";
    std::string req;
    std::string response_body;
    std::string request_body;
    std::unique_ptr<int, std::function<void(int*)>> defer_status(
            (int*)0x01, [&ret, &msg, &status_code, &response_body, &cntl, &req](int*) {
                LOG(INFO) << (ret == 0 ? "succ to " : "failed to ") << __PRETTY_FUNCTION__ << " "
                          << cntl->remote_side() << " request=\n"
                          << req << "\n ret=" << ret << " msg=" << msg;
                cntl->http_response().set_status_code(status_code);
                cntl->response_attachment().append(response_body);
                cntl->response_attachment().append("\n");
            });

    // Prepare input request info
    auto unresolved_path = cntl->http_request().unresolved_path();
    auto uri = cntl->http_request().uri();
    std::stringstream ss;
    ss << "\nuri_path=" << uri.path();
    ss << "\nunresolved_path=" << unresolved_path;
    ss << "\nmethod=" << brpc::HttpMethod2Str(cntl->http_request().method());
    ss << "\nquery strings:";
    for (auto it = uri.QueryBegin(); it != uri.QueryEnd(); ++it) {
        ss << "\n" << it->first << "=" << it->second;
    }
    ss << "\nheaders:";
    for (auto it = cntl->http_request().HeaderBegin(); it != cntl->http_request().HeaderEnd();
         ++it) {
        ss << "\n" << it->first << ":" << it->second;
    }
    req = ss.str();
    ss.clear();
    request_body = cntl->request_attachment().to_string(); // Just copy

    // Auth
    auto token = uri.GetQuery("token");
    if (token == nullptr || *token != config::http_token) {
        msg = "incorrect token, token=" + (token == nullptr ? std::string("(not given)") : *token);
        response_body = "incorrect token";
        status_code = 403;
        return;
    }

    // Process http request
    if (unresolved_path == "decode_key") { // TODO: implement this in a separate src file
        if (uri.GetQuery("key") == nullptr || uri.GetQuery("key")->empty()) {
            msg = "no key to decode";
            response_body = msg;
            status_code = 400;
            return;
        }
        std::string_view key = *uri.GetQuery("key");
        response_body = prettify_key(key);
        if (key.empty()) {
            msg = "failed to decode key, key=" + std::string(key);
            response_body = "failed to decode key, it may be malformed";
            status_code = 400;
            return;
        }
        return;
    }

    if (unresolved_path == "create_instance") {
        CreateInstanceRequest req;
        auto st = google::protobuf::util::JsonStringToMessage(request_body, &req);
        if (!st.ok()) {
            msg = "failed to CreateInstanceRequest, error: " + st.message().ToString();
            response_body = msg;
            LOG(WARNING) << msg;
            return;
        }
        MetaServiceGenericResponse res;
        create_instance(cntl, &req, &res, nullptr);
        ret = res.status().code();
        msg = res.status().msg();
        response_body = msg;
        return;
    }

    if (unresolved_path == "add_cluster") {
        AddClusterRequest req;
        auto st = google::protobuf::util::JsonStringToMessage(request_body, &req);
        if (!st.ok()) {
            msg = "failed to parse AddClusterRequest, error: " + st.message().ToString();
            response_body = msg;
            LOG(WARNING) << msg;
            return;
        }
        MetaServiceGenericResponse res;
        add_cluster(cntl, &req, &res, nullptr);
        ret = res.status().code();
        msg = res.status().msg();
        response_body = msg;
        return;
    }

    // This is useful for debuggin
    if (unresolved_path == "get_cluster") {
        GetClusterRequest req;
        auto st = google::protobuf::util::JsonStringToMessage(request_body, &req);
        if (!st.ok()) {
            msg = "failed to GetClusterRequest, error: " + st.message().ToString();
            response_body = msg;
            LOG(WARNING) << msg;
            return;
        }
        GetClusterResponse res;
        get_cluster(cntl, &req, &res, nullptr);
        ret = res.status().code();
        msg = res.status().msg();
        response_body = msg;
        return;
    }

    // TODO:
    // * unresolved_path == "encode_key"
    // * unresolved_path == "set_token"
    // * etc.
}

// TODO: move to separate file
//==============================================================================
// Resources
//==============================================================================

void MetaServiceImpl::get_obj_store_info(google::protobuf::RpcController* controller,
                                         const ::selectdb::GetObjStoreInfoRequest* request,
                                         ::selectdb::GetObjStoreInfoResponse* response,
                                         ::google::protobuf::Closure* done) {}

void MetaServiceImpl::create_instance(google::protobuf::RpcController* controller,
                                      const ::selectdb::CreateInstanceRequest* request,
                                      ::selectdb::MetaServiceGenericResponse* response,
                                      ::google::protobuf::Closure* done) {
    auto ctrl = static_cast<brpc::Controller*>(controller);
    LOG(INFO) << "rpc from " << ctrl->remote_side() << " request=" << request->DebugString();
    brpc::ClosureGuard closure_guard(done);
    int ret = 0;
    MetaServiceCode code = MetaServiceCode::OK;
    std::string msg = "OK";
    std::unique_ptr<int, std::function<void(int*)>> defer_status(
            (int*)0x01, [&ret, &code, &msg, &response, &ctrl](int*) {
                response->mutable_status()->set_code(code);
                response->mutable_status()->set_msg(msg);
                LOG(INFO) << (ret == 0 ? "succ to " : "failed to ") << __PRETTY_FUNCTION__ << " "
                          << ctrl->remote_side() << " " << msg;
            });

    // Prepare data
    InstanceInfoPB instance;
    instance.set_instance_id(request->has_instance_id() ? request->instance_id() : "");
    instance.set_user_id(request->has_user_id() ? request->user_id() : "");
    instance.set_name(request->has_name() ? request->name() : "");

    if (instance.instance_id().empty()) {
        code = MetaServiceCode::INVALID_ARGUMENT_ERR;
        msg = "instance id not set";
        return;
    }

    // TODO: check existence before proceeding

    InstanceKeyInfo key_info {request->instance_id()};
    std::string key;
    std::string val = instance.SerializeAsString();
    instance_key(key_info, &key);
    if (val.empty()) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        msg = "failed to serialize";
        LOG(ERROR) << msg;
        return;
    }

    LOG(INFO) << "xxx instance json=" << ([&] {
        std::string str;
        google::protobuf::util::MessageToJsonString(instance, &str);
        return str;
    }());

    std::unique_ptr<Transaction> txn;
    ret = txn_kv_->create_txn(&txn);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_CREATE_ERR;
        msg = "failed to create txn";
        LOG(WARNING) << msg << " ret=" << ret;
        return;
    }

    txn->put(key, val);
    LOG(INFO) << "put instance_key=" << hex(key);
    ret = txn->commit();
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_COMMIT_ERR;
        msg = "failed to commit txn";
        LOG(WARNING) << msg << " ret=" << ret;
    }
}

void MetaServiceImpl::add_cluster(google::protobuf::RpcController* controller,
                                  const ::selectdb::AddClusterRequest* request,
                                  ::selectdb::MetaServiceGenericResponse* response,
                                  ::google::protobuf::Closure* done) {
    auto ctrl = static_cast<brpc::Controller*>(controller);
    LOG(INFO) << "rpc from " << ctrl->remote_side() << " request=" << request->DebugString();
    brpc::ClosureGuard closure_guard(done);
    int ret = 0;
    MetaServiceCode code = MetaServiceCode::OK;
    std::string msg = "OK";
    [[maybe_unused]] std::stringstream ss;
    std::unique_ptr<int, std::function<void(int*)>> defer_status(
            (int*)0x01, [&ret, &code, &msg, &response, &ctrl](int*) {
                response->mutable_status()->set_code(code);
                response->mutable_status()->set_msg(msg);
                LOG(INFO) << (ret == 0 ? "succ to " : "failed to ") << __PRETTY_FUNCTION__ << " "
                          << ctrl->remote_side() << " " << msg;
            });

    if (!request->has_instance_id() || !request->has_cluster()) {
        msg = "invalid request instance_id or cluster not given";
        code = MetaServiceCode::INVALID_ARGUMENT_ERR;
        return;
    }

    std::string instance_id = request->instance_id();

    InstanceKeyInfo key_info {instance_id};
    std::string key;
    std::string val;
    instance_key(key_info, &key);

    std::unique_ptr<Transaction> txn;
    ret = txn_kv_->create_txn(&txn);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_CREATE_ERR;
        msg = "failed to create txn";
        LOG(WARNING) << msg << " ret=" << ret;
        return;
    }
    ret = txn->get(key, &val);
    LOG(INFO) << "get instnace_key=" << hex(key);

    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_GET_ERR;
        ss << "failed to get intancece, instance_id=" << instance_id << " ret=" << ret;
        msg = ss.str();
        return;
    }

    InstanceInfoPB instance;
    if (!instance.ParseFromString(val)) {
        msg = "failed to parse InstanceInfoPB";
        code = MetaServiceCode::PROTOBUF_PARSE_ERR;
        return;
    }

    google::protobuf::util::JsonPrintOptions opts;
    opts.preserve_proto_field_names = true;
    LOG(INFO) << "xxx cluster to add json=" << ([&] {
        std::string str;
        google::protobuf::util::MessageToJsonString(request->cluster(), &str);
        return str;
    }());
    LOG(INFO) << "xxx instance json=" << ([&] {
        std::string str;
        google::protobuf::util::MessageToJsonString(instance, &str);
        return str;
    }());

    // TODO:
    // do some check before adding, dedup is needed
    instance.add_clusters()->CopyFrom(request->cluster());
    LOG(INFO) << "instance " << instance_id << " has " << instance.clusters().size() << " clusters";

    val = instance.SerializeAsString();
    if (val.empty()) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        msg = "failed to serialize";
        return;
    }

    txn->put(key, val);
    LOG(INFO) << "put instnace_key=" << hex(key);
    ret = txn->commit();
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_COMMIT_ERR;
        msg = "failed to commit txn";
        LOG(WARNING) << msg << " ret=" << ret;
    }
} // add cluster

void MetaServiceImpl::get_cluster(google::protobuf::RpcController* controller,
                                  const ::selectdb::GetClusterRequest* request,
                                  ::selectdb::GetClusterResponse* response,
                                  ::google::protobuf::Closure* done) {
    auto ctrl = static_cast<brpc::Controller*>(controller);
    LOG(INFO) << "rpc from " << ctrl->remote_side() << " request=" << request->DebugString();
    brpc::ClosureGuard closure_guard(done);
    int ret = 0;
    MetaServiceCode code = MetaServiceCode::OK;
    std::string msg = "OK";
    [[maybe_unused]] std::stringstream ss;
    std::unique_ptr<int, std::function<void(int*)>> defer_status(
            (int*)0x01, [&ret, &code, &msg, &response, &ctrl](int*) {
                response->mutable_status()->set_code(code);
                response->mutable_status()->set_msg(msg);
                LOG(INFO) << (ret == 0 ? "succ to " : "failed to ") << __PRETTY_FUNCTION__ << " "
                          << ctrl->remote_side() << " " << msg;
            });

    std::string instance_id = request->has_instance_id() ? request->instance_id() : "";
    std::string cloud_unique_id = request->has_cloud_unique_id() ? request->cloud_unique_id() : "";
    std::string cluster_id = request->has_cluster_id() ? request->cluster_id() : "";
    std::string cluster_name = request->has_cluster_name() ? request->cluster_name() : "";

    if (cloud_unique_id.empty()) {
        code = MetaServiceCode::INVALID_ARGUMENT_ERR;
        msg = "cloud_unique_id must be given";
        return;
    }

    if (cluster_id.empty() && cluster_name.empty()) {
        code = MetaServiceCode::INVALID_ARGUMENT_ERR;
        msg = "cluster_name or cluster_id must be given";
        return;
    }

    // TODO: get instance_id with cloud_unique_id
    if (instance_id.empty()) {
        code = MetaServiceCode::INVALID_ARGUMENT_ERR;
        msg = "failed to get instance_id with cloud_unique_id=" + cloud_unique_id;
        return;
    }

    InstanceKeyInfo key_info {instance_id};
    std::string key;
    std::string val;
    instance_key(key_info, &key);

    std::unique_ptr<Transaction> txn;
    ret = txn_kv_->create_txn(&txn);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_CREATE_ERR;
        msg = "failed to create txn";
        LOG(WARNING) << msg << " ret=" << ret;
        return;
    }
    ret = txn->get(key, &val);
    LOG(INFO) << "get instnace_key=" << hex(key);

    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_GET_ERR;
        ss << "failed to get intancece, instance_id=" << instance_id << " ret=" << ret;
        msg = ss.str();
        return;
    }

    InstanceInfoPB instance;
    if (!instance.ParseFromString(val)) {
        code = MetaServiceCode::PROTOBUF_PARSE_ERR;
        msg = "failed to parse InstanceInfoPB";
        return;
    }

    for (int i = 0; i < instance.clusters_size(); ++i) {
        auto& c = instance.clusters(i);
        if ((c.has_cluster_name() && c.cluster_name() == cluster_name) ||
            (c.has_cluster_id() && c.cluster_id() == cluster_id)) {
            response->mutable_cluster()->CopyFrom(c);
            google::protobuf::util::JsonPrintOptions opts;
            opts.preserve_proto_field_names = true;
            std::string str;
            google::protobuf::util::MessageToJsonString(response->cluster(), &str, opts);
            msg = str;
            LOG(INFO) << "found a cluster=" << str;
            break;
        }
    }

    if (!response->has_cluster()) {
        ss << "fail to get cluster with " << request->DebugString();
        msg = ss.str();
        std::replace(msg.begin(), msg.end(), '\n', ' ');
        ret = MetaServiceCode::CLUSTER_NOT_FOUND;
        return;
    }

} // get_cluster

} // namespace selectdb
// vim: et ts=4 sw=4 cc=80:
